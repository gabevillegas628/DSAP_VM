import React, { useState, useEffect, useRef, useCallback } from 'react';
import { ZoomIn, ZoomOut, RotateCcw, Download, Eye, EyeOff } from 'lucide-react';

const ChromatogramViewer = ({ fileData, fileName, onClose }) => {
  console.log('ChromatogramViewer props:', { fileData, fileName }); // Debug log
  const canvasRef = useRef(null);

  // Touch scrolling refs
  const isTouchScrolling = useRef(false);
  const touchStartX = useRef(0);
  const touchStartScrollPos = useRef(0);
  const rafPendingScroll = useRef(false);
  const latestTouchX = useRef(0);
  const [parsedData, setParsedData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [zoomLevel, setZoomLevel] = useState(1.5);
  const [scrollPosition, setScrollPosition] = useState(0);
  const [showChannels, setShowChannels] = useState({
    A: true,
    T: true,
    G: true,
    C: true
  });
  const [qualityThreshold, setQualityThreshold] = useState(20);
  const [hoveredPosition, setHoveredPosition] = useState(null);

  // Add state for selected position
  const [selectedPosition, setSelectedPosition] = useState(null);
  const [selectedNucleotide, setSelectedNucleotide] = useState(null);

  // Add state for highligting regions
  const [highlightStart, setHighlightStart] = useState('');
  const [highlightEnd, setHighlightEnd] = useState('');
  const [showHighlight, setShowHighlight] = useState(false);

  // Add state for editing
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState('');
  const [editedPositions, setEditedPositions] = useState(new Set());

  // Add state for confirmation modal
  const [showConfirmModal, setShowConfirmModal] = useState(false);
  const [pendingEdit, setPendingEdit] = useState(null); // {position, oldBase, newBase}


  // Add keyboard shortcuts for editing bases
  useEffect(() => {
    const handleKeyPress = (e) => {
      if (selectedPosition === null || isEditing || showConfirmModal) return;
      
      // CRITICAL: Ignore keypresses if user is typing in a form field
      // Use e.target instead of document.activeElement for reliability
      const targetElement = e.target;
      if (
        targetElement.tagName === 'INPUT' ||
        targetElement.tagName === 'TEXTAREA' ||
        targetElement.isContentEditable ||
        targetElement.getAttribute('contenteditable') === 'true'
      ) {
        return;
      }
      
      const key = e.key.toUpperCase();
      if (['A', 'T', 'G', 'C', 'N'].includes(key)) {
        // Show confirmation modal before editing
        const oldBase = parsedData.baseCalls[selectedPosition];
        setPendingEdit({
          position: selectedPosition,
          oldBase: oldBase,
          newBase: key
        });
        setShowConfirmModal(true);
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [selectedPosition, isEditing, parsedData, showConfirmModal]);

  // Function to confirm the base edit
  const confirmBaseEdit = () => {
    if (!pendingEdit) return;

    const { position, newBase } = pendingEdit;
    const newBaseCalls = [...parsedData.baseCalls];
    newBaseCalls[position] = newBase;

    const newParsedData = {
      ...parsedData,
      baseCalls: newBaseCalls,
      sequence: newBaseCalls.join('')
    };

    setEditedPositions(prev => new Set([...prev, position]));
    setParsedData(newParsedData);
    setSelectedNucleotide(newBase);
    
    console.log(`Edited position ${position + 1} from ${pendingEdit.oldBase} to ${newBase}`);
    
    // Close modal and clear pending edit
    setShowConfirmModal(false);
    setPendingEdit(null);
  };

  // Function to cancel the base edit
  const cancelBaseEdit = () => {
    setShowConfirmModal(false);
    setPendingEdit(null);
  };



  useEffect(() => {
    if (fileData) {
      parseChromatogramFile(fileData);
    }
  }, [fileData]);

  // FIX: Improved effect with proper cleanup and timing
  useEffect(() => {
    if (parsedData && canvasRef.current) {
      const timer = setTimeout(() => {
        drawChromatogram();
      }, 10);
      return () => clearTimeout(timer);
    }
  }, [parsedData, zoomLevel, scrollPosition, showChannels, qualityThreshold, selectedPosition, hoveredPosition, isEditing]);

  // FIX: Add cleanup on unmount
  useEffect(() => {
    return () => {
      // Cleanup canvas context if component unmounts
      if (canvasRef.current) {
        const ctx = canvasRef.current.getContext('2d');
        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
      }
    };
  }, []);

  // Handle window resize events
  useEffect(() => {
    const handleResize = () => {
      if (parsedData) {
        // Add small delay to avoid rapid redraws
        setTimeout(() => {
          drawChromatogram();
        }, 100);
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [parsedData]);

  // Add this useEffect for wheel event handling
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const handleWheel = (e) => {
      e.preventDefault();
      e.stopPropagation();

      const scrollDelta = e.deltaX !== 0 ? e.deltaX : e.deltaY;
      const scrollAmount = scrollDelta > 0 ? 0.003 : -0.003;

      setScrollPosition(prev => Math.max(0, Math.min(1, prev + scrollAmount)));

      return false;
    };

    // Add with passive: false to ensure preventDefault works
    canvas.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      canvas.removeEventListener('wheel', handleWheel);
    };
  }, [parsedData]); // Only re-attach when parsedData changes, not on every scroll

  // Add ResizeObserver to handle container size changes
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !canvas.parentElement) return;

    const resizeObserver = new ResizeObserver(() => {
      // Wrap in RAF to prevent layout thrashing and ResizeObserver loop errors
      requestAnimationFrame(() => {
        drawChromatogram();
      });
    });

    resizeObserver.observe(canvas.parentElement);

    return () => {
      resizeObserver.disconnect();
    };
  }, [parsedData, zoomLevel, scrollPosition, showChannels]); // Redraw when these change

  // Add touch scrolling to canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    let touchStartX = 0;
    let touchStartScrollPos = 0;
    let isTouchScrolling = false;

    const handleTouchStart = (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartScrollPos = scrollPosition;
        isTouchScrolling = true;
      }
    };

    const handleTouchMove = (e) => {
      if (!isTouchScrolling || e.touches.length !== 1) return;

      e.preventDefault(); // Prevent page scrolling

      const touchCurrentX = e.touches[0].clientX;
      const deltaX = touchStartX - touchCurrentX;

      // Convert pixel movement to scroll position change (sensitivity adjustment)
      const scrollDelta = deltaX / canvas.width;

      const newScrollPos = Math.max(0, Math.min(1, touchStartScrollPos + scrollDelta));
      setScrollPosition(newScrollPos);
    };

    const handleTouchEnd = () => {
      isTouchScrolling = false;
    };

    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd);

    return () => {
      canvas.removeEventListener('touchstart', handleTouchStart);
      canvas.removeEventListener('touchmove', handleTouchMove);
      canvas.removeEventListener('touchend', handleTouchEnd);
    };
  }, [scrollPosition]);

  const handleSaveEdit = () => {
    if (!editValue || selectedPosition === null) return;

    // Create a new copy of the baseCalls array with the edit
    const newBaseCalls = [...parsedData.baseCalls];
    newBaseCalls[selectedPosition] = editValue;

    // Update the parsedData with the new base calls
    const newParsedData = {
      ...parsedData,
      baseCalls: newBaseCalls,
      sequence: newBaseCalls.join('') // Update the sequence string too
    };

    // Track that this position was edited
    setEditedPositions(prev => new Set([...prev, selectedPosition]));

    setParsedData(newParsedData);

    // Update the selected nucleotide display
    setSelectedNucleotide(editValue);

    // Exit editing mode
    setIsEditing(false);
    setEditValue('');

    console.log(`Edited position ${selectedPosition + 1} from ${selectedNucleotide} to ${editValue}`);
  };

  const handleCancelEdit = () => {
    setIsEditing(false);
    setEditValue('');
  };


  const parseChromatogramFile = async (data) => {
    try {
      setLoading(true);
      console.log('parseChromatogramFile called with data:', data, 'fileName:', fileName);

      let parsedData;

      // Check if we have real binary data or mock indicator
      if (data === 'mock' || !data || data.length < 100) {
        console.log('No real file data available');
        setError('Could not load chromatogram data');
        setLoading(false);
        return;
      } else {
        console.log('Parsing real file data, size:', data.length, 'bytes');
        try {
          // Detect file type
          const fileType = detectFileType(data);
          console.log('Detected file type:', fileType);

          if (fileType === 'SCF') {
            parsedData = parseRealSCFData(data, fileName);
          } else if (fileType === 'AB1') {
            parsedData = parseRealAB1Data(data, fileName);
          } else {
            throw new Error('Unsupported file format - not AB1 or SCF');
          }
        } catch (parseError) {
          console.error('Failed to parse file data:', parseError);
          setError('Could not load chromatogram data');
          setLoading(false);
          return;
        }
      }

      setParsedData(parsedData);
      setLoading(false);
    } catch (err) {
      console.error('Error in parseChromatogramFile:', err);
      setError('Could not load chromatogram data');
      setLoading(false);
    }
  };

  // File type detection function
  const detectFileType = (uint8Array) => {
    if (uint8Array.length < 4) {
      throw new Error('File too small to determine type');
    }

    // Check for SCF magic bytes: 2E 73 63 66 (.scf in ASCII)
    if (uint8Array[0] === 0x2E && uint8Array[1] === 0x73 &&
      uint8Array[2] === 0x63 && uint8Array[3] === 0x66) {
      return 'SCF';
    }

    // Check for AB1 magic bytes: ABIF
    const signature = new TextDecoder().decode(uint8Array.slice(0, 4));
    if (signature === 'ABIF') {
      return 'AB1';
    }

    throw new Error('Unknown file format - not AB1 or SCF');
  };

  // New function to parse real SCF binary data
  // New function to parse real SCF binary data
  const parseRealSCFData = (uint8Array, fileName) => {
    console.log('Starting real SCF parsing...');

    // SCF files start with ".scf" signature (2E 73 63 66)
    if (uint8Array[0] !== 0x2E || uint8Array[1] !== 0x73 ||
      uint8Array[2] !== 0x63 || uint8Array[3] !== 0x66) {
      throw new Error('Not a valid SCF file - missing .scf signature');
    }

    // Create DataView for reading binary data
    const dataView = new DataView(uint8Array.buffer);

    // SCF header structure (starting at byte 0)
    const magic = dataView.getUint32(0, false); // Should be 0x2E736366 (.scf)
    const samples = dataView.getUint32(4, false); // Number of sample points
    const samplesOffset = dataView.getUint32(8, false); // Offset to sample data
    const bases = dataView.getUint32(12, false); // Number of bases
    const basesLeftClip = dataView.getUint32(16, false); // Left clip point
    const basesRightClip = dataView.getUint32(20, false); // Right clip point  
    const basesOffset = dataView.getUint32(24, false); // Offset to base data
    const commentsSize = dataView.getUint32(28, false); // Size of comments
    const commentsOffset = dataView.getUint32(32, false); // Offset to comments
    const version = new TextDecoder().decode(uint8Array.slice(36, 40)); // Version string
    const sampleSize = dataView.getUint32(40, false); // Sample size (1 or 2 bytes)
    const codeSet = dataView.getUint32(44, false); // Code set
    const privateSize = dataView.getUint32(48, false); // Private data size
    const privateOffset = dataView.getUint32(52, false); // Private data offset

    console.log(`SCF file: ${samples} samples, ${bases} bases, version ${version}`);

    // Validate header values
    if (samples === 0 || bases === 0) {
      throw new Error('Invalid SCF file - no samples or bases found');
    }

    console.log('SCF Header Details:', {
      samples,
      samplesOffset,
      bases,
      basesOffset,
      sampleSize,
      version: version.replace(/\0/g, ''), // Remove null bytes
      codeSet
    });

    // Read trace data (samples)
    const traces = { A: [], T: [], G: [], C: [] };
    const channels = ['A', 'C', 'G', 'T']; // SCF standard order

    // SCF stores 4 channels of sample data
    for (let channel = 0; channel < 4; channel++) {
      const channelName = channels[channel];
      const channelOffset = samplesOffset + (channel * samples * sampleSize);

      for (let i = 0; i < samples; i++) {
        const sampleOffset = channelOffset + (i * sampleSize);
        let value;

        if (sampleSize === 1) {
          // 8-bit samples
          value = uint8Array[sampleOffset];
        } else if (sampleSize === 2) {
          // 16-bit samples (big-endian)
          value = dataView.getUint16(sampleOffset, false);
        } else {
          throw new Error(`Unsupported sample size: ${sampleSize}`);
        }

        traces[channelName].push(value);
      }

      console.log(`Loaded ${traces[channelName].length} trace points for channel ${channelName}`);
    }

    // Apply smoothing to SCF traces
    console.log('Applying smoothing to SCF traces...');
    traces.A = smoothData(traces.A, 3);
    traces.C = smoothData(traces.C, 3);
    traces.G = smoothData(traces.G, 3);
    traces.T = smoothData(traces.T, 3);

    // Read base call data
    const baseCalls = [];
    const quality = [];
    const peakLocations = [];

    // Each base entry is 12 bytes in SCF format
    const baseEntrySize = 12;

    for (let i = 0; i < bases; i++) {
      const baseOffset = basesOffset + (i * baseEntrySize);

      if (baseOffset + baseEntrySize > uint8Array.length) {
        console.warn(`Base ${i} extends beyond file length, stopping at ${baseCalls.length} bases`);
        break;
      }

      try {
        // Read all the base entry data first
        const peakIndex = dataView.getUint16(baseOffset, false); // SCF uses 16-bit peak locations
        const probA = uint8Array[baseOffset + 4] || 0;
        const probC = uint8Array[baseOffset + 5] || 0;
        const probG = uint8Array[baseOffset + 6] || 0;
        const probT = uint8Array[baseOffset + 7] || 0;

        // For this SCF variant, always use estimated peak positions
        const estimatedPeak = Math.floor((i / bases) * samples);
        peakLocations.push(estimatedPeak);

        // Enhanced debugging for problematic range
        if (i >= 405 && i <= 410) {
          const byte0 = uint8Array[baseOffset];
          const byte1 = uint8Array[baseOffset + 1];
          const byte2 = uint8Array[baseOffset + 2];
          const byte3 = uint8Array[baseOffset + 3];
          const peak16 = dataView.getUint16(baseOffset, false);
          const peak32 = dataView.getUint32(baseOffset, false);
          console.log(`Base ${i}: bytes=[${byte0}, ${byte1}, ${byte2}, ${byte3}], peak16=${peak16}, peak32=${peak32}, probs=[A:${probA}, C:${probC}, G:${probG}, T:${probT}]`);
        }

        // Peak location handling with better validation
        // Peak location handling - use estimated positions for SCF files
        // SCF peak data in this file appears unreliable, so we'll calculate positions
        peakLocations.push(estimatedPeak);

        // Debug comparison for a few bases
        if (i >= 405 && i <= 410) {
          const storedPeak16 = dataView.getUint16(baseOffset, false);
          const storedPeak32 = dataView.getUint32(baseOffset, false);
          console.log(`Base ${i}: stored16=${storedPeak16}, stored32=${storedPeak32}, estimated=${estimatedPeak}, probs=[A:${probA}, C:${probC}, G:${probG}, T:${probT}]`);
        }

        if (i >= 405 && i <= 410) {
          console.log(`=== Base ${i} - Full 12-byte structure ===`);
          for (let j = 0; j < 12; j++) {
            const byteVal = uint8Array[baseOffset + j];
            console.log(`  Byte ${j}: ${byteVal} (0x${byteVal.toString(16).padStart(2, '0')}) = '${byteVal > 31 && byteVal < 127 ? String.fromCharCode(byteVal) : 'non-printable'}'`);
          }

          // Try reading peak index from different positions
          const peak_0_16 = dataView.getUint16(baseOffset + 0, false);
          const peak_0_32 = dataView.getUint32(baseOffset + 0, false);
          const peak_2_16 = dataView.getUint16(baseOffset + 2, false);
          const peak_4_16 = dataView.getUint16(baseOffset + 4, false);

          console.log(`  Peak attempts: @0(16)=${peak_0_16}, @0(32)=${peak_0_32}, @2(16)=${peak_2_16}, @4(16)=${peak_4_16}`);
          console.log(`  Probs: A:${probA}, C:${probC}, G:${probG}, T:${probT}`);
          console.log('');
        }

        // Base call determination with multiple methods
        const rawByteValue = uint8Array[baseOffset + 8];
        let baseCall = 'N';

        // Method 1: Try ASCII character at byte 8
        if (rawByteValue >= 65 && rawByteValue <= 90) {
          baseCall = String.fromCharCode(rawByteValue);
        } else if (rawByteValue >= 97 && rawByteValue <= 122) {
          baseCall = String.fromCharCode(rawByteValue).toUpperCase();
        } else {
          // Method 2: Derive from probability values
          const maxProb = Math.max(probA, probC, probG, probT);
          if (maxProb > 0) {
            if (probA === maxProb) {
              baseCall = 'A';
            } else if (probC === maxProb) {
              baseCall = 'C';
            } else if (probG === maxProb) {
              baseCall = 'G';
            } else if (probT === maxProb) {
              baseCall = 'T';
            }
          }

          // Method 3: Try other bytes if still 'N'
          if (baseCall === 'N' && maxProb === 0) {
            for (let j = 9; j < 12; j++) {
              const altByte = uint8Array[baseOffset + j];
              if (altByte >= 65 && altByte <= 90) {
                baseCall = String.fromCharCode(altByte);
                break;
              } else if (altByte >= 97 && altByte <= 122) {
                baseCall = String.fromCharCode(altByte).toUpperCase();
                break;
              }
            }
          }
        }

        // Debug base call derivation for first 10 bases
        if (i < 10) {
          const maxProb = Math.max(probA, probC, probG, probT);
          console.log(`Base ${i}: derived='${baseCall}' from probs [A:${probA}, C:${probC}, G:${probG}, T:${probT}], max=${maxProb}`);
        }

        // Final validation
        if (!/^[ATGCN]$/.test(baseCall)) {
          baseCall = 'N';
        }

        baseCalls.push(baseCall);

        // Calculate quality score
        const maxProb = Math.max(probA, probC, probG, probT);
        const qualityScore = maxProb > 0 ? Math.round((maxProb / 255) * 60) : 20;
        quality.push(qualityScore);

      } catch (error) {
        console.warn(`Error reading base ${i}:`, error);
        baseCalls.push('N');
        quality.push(20);
        peakLocations.push(Math.floor((i / bases) * samples));
      }
    }

    console.log(`Successfully read ${baseCalls.length} bases`);
    console.log('First 10 bases:', baseCalls.slice(0, 10));
    console.log('First 10 peak locations:', peakLocations.slice(0, 10));
    console.log('Base call distribution:', {
      A: baseCalls.filter(b => b === 'A').length,
      T: baseCalls.filter(b => b === 'T').length,
      G: baseCalls.filter(b => b === 'G').length,
      C: baseCalls.filter(b => b === 'C').length,
      N: baseCalls.filter(b => b === 'N').length
    });

    console.log(`Loaded ${baseCalls.length} base calls with peak locations`);

    // Build sequence string  
    const sequence = baseCalls.join('');

    // Validate we have data
    if (Object.values(traces).every(trace => trace.length === 0)) {
      throw new Error('No trace data found in SCF file');
    }

    if (baseCalls.length === 0) {
      throw new Error('No base calls found in SCF file');
    }

    console.log(`Successfully parsed SCF: ${sequence.length} bases, ${samples} trace points`);

    return {
      sequence,
      traces,
      quality,
      baseCalls,
      peakLocations,
      fileName: fileName || 'parsed.scf',
      sequenceLength: baseCalls.length,
      fileFormat: 'SCF'
    };
  };

  // New function to parse real AB1 binary data
  const parseRealAB1Data = (uint8Array, fileName) => {
    console.log('Starting real AB1 parsing...');

    // AB1 files start with "ABIF" signature
    const signature = new TextDecoder().decode(uint8Array.slice(0, 4));
    if (signature !== 'ABIF') {
      throw new Error('Not a valid AB1 file - missing ABIF signature');
    }

    // Create DataView for reading binary data
    const dataView = new DataView(uint8Array.buffer);

    // Read the directory structure (starts at byte 26)
    const directoryOffset = dataView.getUint32(26, false); // big endian
    const numEntries = dataView.getUint32(18, false);

    console.log(`AB1 file has ${numEntries} directory entries at offset ${directoryOffset}`);

    // Parse directory entries to find data we need
    const entries = {};
    for (let i = 0; i < numEntries; i++) {
      const entryOffset = directoryOffset + (i * 28);

      // Read entry header
      const name = new TextDecoder().decode(uint8Array.slice(entryOffset, entryOffset + 4));
      const number = dataView.getUint32(entryOffset + 4, false);
      const elementType = dataView.getUint16(entryOffset + 8, false);
      const elementSize = dataView.getUint16(entryOffset + 10, false);
      const numElements = dataView.getUint32(entryOffset + 12, false);
      const dataSize = dataView.getUint32(entryOffset + 16, false);
      const dataOffset = dataView.getUint32(entryOffset + 20, false);

      const key = `${name}${number}`;
      entries[key] = {
        name,
        number,
        elementType,
        elementSize,
        numElements,
        dataSize,
        dataOffset
      };
    }

    console.log('Found AB1 entries:', Object.keys(entries));

    // Extract trace data (DATA tags 9-12) and map to correct channels
    const traces = { A: [], T: [], G: [], C: [] };

    // Check if there's a channel order tag (FWO_1) to get the correct mapping
    let channelOrder = ['A', 'T', 'G', 'C']; // default order
    if (entries['FWO_1']) {
      const entry = entries['FWO_1'];
      const orderData = uint8Array.slice(entry.dataOffset, entry.dataOffset + entry.dataSize);
      channelOrder = Array.from(orderData).map(byte => String.fromCharCode(byte)).filter(char => /[ATGC]/.test(char));
      console.log('Found channel order:', channelOrder);
    }

    // If no FWO tag or it's incomplete, try common mappings
    if (channelOrder.length !== 4) {
      // ABI 3730/3130 common order is G,A,T,C for DATA9-12
      channelOrder = ['G', 'A', 'T', 'C'];
      console.log('Using default channel order:', channelOrder);
    }

    for (let i = 0; i < 4; i++) {
      const dataKey = `DATA${9 + i}`;
      if (entries[dataKey] && i < channelOrder.length) {
        const entry = entries[dataKey];
        const traceData = [];

        // Read trace values (usually 16-bit integers)
        for (let j = 0; j < entry.numElements; j++) {
          const offset = entry.dataOffset + (j * 2);
          if (offset + 1 < uint8Array.length) {
            const value = dataView.getUint16(offset, false);
            traceData.push(value);
          }
        }

        const channel = channelOrder[i];
        traces[channel] = traceData;
        console.log(`Loaded ${traceData.length} trace points for DATA${9 + i} -> channel ${channel}`);
      }
    }

    // Extract base calls (PBAS tag)
    let baseCalls = [];
    if (entries['PBAS1']) {
      const entry = entries['PBAS1'];
      const baseCallData = uint8Array.slice(entry.dataOffset, entry.dataOffset + entry.dataSize);
      baseCalls = Array.from(baseCallData).map(byte => String.fromCharCode(byte)).filter(char => /[ATGCN]/.test(char));
      console.log(`Loaded ${baseCalls.length} base calls`);
    }

    // Extract quality scores (PCON tag)
    let quality = [];
    if (entries['PCON1']) {
      const entry = entries['PCON1'];
      for (let i = 0; i < entry.numElements && i < baseCalls.length; i++) {
        const offset = entry.dataOffset + i;
        if (offset < uint8Array.length) {
          quality.push(uint8Array[offset]);
        }
      }
      console.log(`Loaded ${quality.length} quality scores`);
    }

    // If we don't have quality data, generate reasonable defaults
    if (quality.length === 0 && baseCalls.length > 0) {
      quality = baseCalls.map(() => Math.floor(Math.random() * 40) + 20);
      console.log('Generated default quality scores');
    }

    const maxTraceLength = Math.max(...Object.values(traces).map(t => t.length));

    // Extract peak locations (PLOC tag)
    let peakLocations = [];
    if (entries['PLOC1']) {
      const entry = entries['PLOC1'];
      for (let i = 0; i < entry.numElements && i < baseCalls.length; i++) {
        const offset = entry.dataOffset + (i * 2);
        if (offset + 1 < uint8Array.length) {
          const peakPos = dataView.getUint16(offset, false);
          peakLocations.push(peakPos);
        }
      }
      console.log(`Loaded ${peakLocations.length} peak locations`);
    }

    // If no peak locations found, calculate estimated positions
    if (peakLocations.length === 0 && baseCalls.length > 0) {
      const estimatedSpacing = maxTraceLength / baseCalls.length;
      peakLocations = baseCalls.map((_, i) => Math.round(i * estimatedSpacing));
      console.log('Generated estimated peak locations');
    }

    // Build sequence string
    const sequence = baseCalls.join('');

    // Validate we have data
    if (Object.values(traces).every(trace => trace.length === 0)) {
      throw new Error('No trace data found in AB1 file');
    }

    if (baseCalls.length === 0) {
      throw new Error('No base calls found in AB1 file');
    }

    console.log(`Successfully parsed AB1: ${sequence.length} bases, ${Math.max(...Object.values(traces).map(t => t.length))} trace points`);

    return {
      sequence,
      traces,
      quality,
      baseCalls,
      peakLocations,
      fileName: fileName || 'parsed.ab1',
      sequenceLength: baseCalls.length,
      fileFormat: 'AB1'
    };
  };


  // Smoothing function to reduce noise (enhanced)
  const smoothData = (data, windowSize = 7) => {
    const smoothed = [...data];
    const halfWindow = Math.floor(windowSize / 2);

    for (let i = halfWindow; i < data.length - halfWindow; i++) {
      let sum = 0;
      let weightSum = 0;

      // Apply Gaussian-like weighting for better smoothing
      for (let j = -halfWindow; j <= halfWindow; j++) {
        const weight = Math.exp(-(j * j) / (2 * (halfWindow / 2) * (halfWindow / 2)));
        sum += data[i + j] * weight;
        weightSum += weight;
      }
      smoothed[i] = sum / weightSum;
    }

    return smoothed;
  };

  // FIX: Helper function for consistent position calculation
  const getBaseXPosition = (baseIndex, startIndex, endIndex, canvasWidth) => {
    return ((baseIndex * 4 - startIndex) / (endIndex - startIndex)) * canvasWidth;
  };

  const drawChromatogram = () => {
    const canvas = canvasRef.current;
    if (!canvas || !parsedData) return;

    const ctx = canvas.getContext('2d');
    const { traces, quality, baseCalls } = parsedData;

    // Validate trace data
    const traceLengths = Object.values(traces).map(trace => trace.length);
    const maxTraceLength = Math.max(...traceLengths);

    if (maxTraceLength === 0) {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#FF0000';
      ctx.font = '16px sans-serif';
      ctx.fillText('No trace data available', 50, 50);
      return;
    }

    // Set canvas size dynamically based on container
    const container = canvas.parentElement;
    if (container) {
      canvas.width = container.offsetWidth || 1200;
      canvas.height = container.offsetHeight || 300;
    } else {
      // Fallback to larger default sizes
      canvas.width = 1600;
      canvas.height = 300;
    }

    // Clear canvas
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Calculate visible range
    const dataLength = maxTraceLength;
    const visiblePoints = Math.floor(canvas.width / zoomLevel);
    const startIndex = Math.floor(scrollPosition * (dataLength - visiblePoints));
    const endIndex = Math.min(startIndex + visiblePoints, dataLength);

    // Find the maximum value in the visible range for normalization
    let maxValue = 0;
    Object.values(traces).forEach(trace => {
      for (let i = startIndex; i < endIndex && i < trace.length; i++) {
        maxValue = Math.max(maxValue, trace[i]);
      }
    });

    // Prevent division by zero
    if (maxValue === 0) maxValue = 1;

    // Draw chromatogram traces with normalization
    const colors = {
      A: '#00AA00', // Green
      T: '#FF0000', // Red
      G: '#000000', // Black
      C: '#0000FF'  // Blue
    };

    // Dynamic layout based on canvas height
    const baseCallHeight = 30;  // Space for base call letters at top
    const bottomReserve = 50;   // Space for quality bars, tick marks, and position numbers
    const traceHeight = Math.max(100, canvas.height - baseCallHeight - bottomReserve); // Available height for traces
    const baselineY = baseCallHeight + traceHeight;

    Object.entries(traces).forEach(([base, data]) => {
      if (!showChannels[base] || data.length === 0) return;

      ctx.strokeStyle = colors[base];
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();

      let pathStarted = false;

      for (let i = startIndex; i < endIndex && i < data.length; i++) {
        const x = ((i - startIndex) / (endIndex - startIndex)) * canvas.width;
        // Normalize the y value to fit in available height
        const normalizedValue = (data[i] / maxValue) * traceHeight;
        const y = baselineY - normalizedValue;

        if (!pathStarted) {
          ctx.moveTo(x, y);
          pathStarted = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
    });


    // Draw base calls and quality (SINGLE LOOP ONLY)
    ctx.font = 'bold 16px monospace';

    const { peakLocations } = parsedData;

    for (let i = 0; i < baseCalls.length; i++) {
      // Use actual peak location or fallback to estimated position
      const peakPosition = peakLocations && peakLocations[i]
        ? peakLocations[i]
        : (i * maxTraceLength / baseCalls.length);

      // Check if this peak is in the visible range
      if (peakPosition < startIndex || peakPosition > endIndex) continue;

      const x = ((peakPosition - startIndex) / (endIndex - startIndex)) * canvas.width;
      const base = baseCalls[i];
      const qual = quality[i] || 0;

      // Only draw if position is visible
      if (x >= -20 && x <= canvas.width + 20) {
        // Highlight selected position
        if (selectedPosition === i) {
          ctx.fillStyle = '#FFD700';
          ctx.fillRect(x - 12, 5, 24, baseCallHeight - 5);
          ctx.strokeStyle = '#FF6600';
          ctx.lineWidth = 2;
          ctx.strokeRect(x - 12, 5, 24, baseCallHeight - 5);
        }

        // Highlight N bases with transparent red background
        if (base === 'N') {
          ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; // Transparent red
          ctx.fillRect(x - 12, 5, 24, baseCallHeight - 5);
          ctx.strokeStyle = '#FF0000'; // Red border
          ctx.lineWidth = 1;
          ctx.strokeRect(x - 12, 5, 24, baseCallHeight - 5);
        }

        // Highlight edited positions with a different color
        if (editedPositions.has(i)) {
          ctx.fillStyle = 'rgba(128, 0, 255, 0.3)'; // Purple tint for edited bases
          ctx.fillRect(x - 12, 5, 24, baseCallHeight - 5);
          ctx.strokeStyle = '#8000FF';
          ctx.lineWidth = 1;
          ctx.strokeRect(x - 12, 5, 24, baseCallHeight - 5);
        }

        // Always color base calls by their nucleotide type
        ctx.fillStyle = colors[base] || '#666666';

        // Draw base letter
        ctx.fillText(base, x - 6, baseCallHeight - 5);

        // Draw quality bar
        ctx.fillStyle = qual >= qualityThreshold ? colors[base] || '#666666' : '#CCCCCC';
        const barHeight = (qual / 60) * 12;
        ctx.fillRect(x - 2, baselineY + 5, 4, barHeight);  // Changed +20 to +5
      }
    }


    // Draw position markers at the bottom
    ctx.fillStyle = '#666666';
    ctx.font = '24px monospace';

    const positionInterval = zoomLevel > 10 ? 10 : zoomLevel > 5 ? 25 : 50;

    for (let pos = 0; pos < baseCalls.length; pos += positionInterval) {
      const peakPosition = peakLocations && peakLocations[pos]
        ? peakLocations[pos]
        : (pos * maxTraceLength / baseCalls.length);

      if (peakPosition < startIndex || peakPosition > endIndex) continue;

      const x = ((peakPosition - startIndex) / (endIndex - startIndex)) * canvas.width;

      if (x >= 0 && x <= canvas.width) {
        // Draw position number
        ctx.fillStyle = '#666666';
        ctx.fillText((pos + 1).toString(), x - 10, canvas.height - 5);  // Now shows 1-based positions

        // Draw tick mark
        ctx.strokeStyle = '#CCCCCC';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, baselineY + 20);  // Start just below quality bars
        ctx.lineTo(x, canvas.height - 15);  // End just above position numbers
        ctx.stroke();
      }
    }


    // Draw selected position highlight line
    if (selectedPosition !== null) {
      const { peakLocations } = parsedData;
      const peakPosition = peakLocations && peakLocations[selectedPosition]
        ? peakLocations[selectedPosition]
        : (selectedPosition * maxTraceLength / baseCalls.length);

      const selectedX = ((peakPosition - startIndex) / (endIndex - startIndex)) * canvas.width;
      if (selectedX >= 0 && selectedX <= canvas.width) {
        ctx.strokeStyle = '#FF6600';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(selectedX, baseCallHeight);
        ctx.lineTo(selectedX, baselineY + 20);  // End just below quality bars
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Draw hover highlight
    if (hoveredPosition !== null && hoveredPosition !== selectedPosition) {
      const { peakLocations } = parsedData;
      const peakPosition = peakLocations && peakLocations[hoveredPosition]
        ? peakLocations[hoveredPosition]
        : (hoveredPosition * maxTraceLength / baseCalls.length);

      const hoverX = ((peakPosition - startIndex) / (endIndex - startIndex)) * canvas.width;
      if (hoverX >= 0 && hoverX <= canvas.width) {
        ctx.fillStyle = 'rgba(173, 216, 230, 0.4)';
        ctx.fillRect(hoverX - 12, 5, 24, baselineY + 20 - 5);  // Height from top to below quality bars
      }
    }

    // Draw quality threshold line
    ctx.strokeStyle = '#FF6B6B';
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    const thresholdY = baselineY + 20 + (qualityThreshold / 60) * 12;
    ctx.moveTo(0, thresholdY);
    ctx.lineTo(canvas.width, thresholdY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw scale info
    ctx.fillStyle = '#666666';
    ctx.font = '10px sans-serif';

    // Draw sequence highlight
    if (showHighlight && highlightStart && highlightEnd && parsedData) {
      const startPos = parseInt(highlightStart) - 1;
      const endPos = parseInt(highlightEnd) - 1;

      if (!isNaN(startPos) && !isNaN(endPos) && startPos >= 0 && endPos < baseCalls.length && startPos <= endPos) {
        const { peakLocations } = parsedData;

        // Get start and end positions
        const startPeakPosition = peakLocations && peakLocations[startPos]
          ? peakLocations[startPos]
          : (startPos * maxTraceLength / baseCalls.length);
        const endPeakPosition = peakLocations && peakLocations[endPos]
          ? peakLocations[endPos]
          : (endPos * maxTraceLength / baseCalls.length);

        // Check if highlight is in visible range
        if (endPeakPosition >= startIndex && startPeakPosition <= endIndex) {
          const startX = Math.max(0, ((startPeakPosition - startIndex) / (endIndex - startIndex)) * canvas.width);
          const endX = Math.min(canvas.width, ((endPeakPosition - startIndex) / (endIndex - startIndex)) * canvas.width);

          // Draw highlight background
          ctx.fillStyle = 'rgba(255, 255, 0, 0.3)'; // Yellow with transparency
          ctx.fillRect(startX - 12, 5, endX - startX + 24, baselineY + 20 - 5);

          // Draw highlight borders
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 2;
          ctx.setLineDash([]);
          ctx.beginPath();
          ctx.moveTo(startX, 5);
          ctx.lineTo(startX, baselineY + 20);
          ctx.moveTo(endX, 5);
          ctx.lineTo(endX, baselineY + 20);
          ctx.stroke();
        }
      }
    }
  };

  const handleZoom = (delta) => {
    setZoomLevel(prev => Math.max(0.5, Math.min(20, prev + delta)));
  };

  // Handle navigation (moved to double-click)
  const handleNavigation = (e) => {
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const scrollRatio = x / rect.width;
    setScrollPosition(Math.max(0, Math.min(1, scrollRatio)));
  };

  // FIX: Improved canvas click handling
  // Updated handleCanvasClick
  const handleCanvasClick = (e) => {
    if (!parsedData) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();

    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const canvasX = (e.clientX - rect.left) * scaleX;
    const canvasY = (e.clientY - rect.top) * scaleY;

    console.log('Click at canvas X:', canvasX, 'Y:', canvasY);

    // Calculate visible range
    const traceLengths = Object.values(parsedData.traces).map(trace => trace.length);
    const maxTraceLength = Math.max(...traceLengths);
    const dataLength = maxTraceLength;
    const visiblePoints = Math.floor(canvas.width / zoomLevel);
    const startIndex = Math.floor(scrollPosition * (dataLength - visiblePoints));
    const endIndex = Math.min(startIndex + visiblePoints, dataLength);

    console.log('Visible range:', startIndex, 'to', endIndex);

    // Calculate the actual ratio for real data
    const dataPointsPerBase = maxTraceLength / parsedData.baseCalls.length;

    // Find the closest base call position
    let closestPosition = null;
    let closestDistance = Infinity;

    for (let i = 0; i < parsedData.baseCalls.length; i++) {
      const peakPosition = parsedData.peakLocations && parsedData.peakLocations[i]
        ? parsedData.peakLocations[i]
        : (i * maxTraceLength / parsedData.baseCalls.length);

      if (peakPosition < startIndex || peakPosition > endIndex) continue;

      const baseX = ((peakPosition - startIndex) / (endIndex - startIndex)) * canvas.width;
      const distance = Math.abs(canvasX - baseX);

      if (distance < closestDistance) {
        closestDistance = distance;
        closestPosition = i;
      }
    }

    console.log('Closest position:', closestPosition, 'Distance:', closestDistance);

    if (closestPosition !== null && closestDistance < 50 && closestPosition >= 0) {
      const nucleotide = parsedData.baseCalls[closestPosition];
      setSelectedPosition(closestPosition);
      setSelectedNucleotide(nucleotide);
      console.log(`Selected: ${nucleotide}${closestPosition + 1}`);
    } else {
      console.log('Click too far from any base position or invalid position');
      setSelectedPosition(null);
      setSelectedNucleotide(null);
    }
  };

  // Updated handleCanvasMouseMove
  const handleCanvasMouseMove = (e) => {
    if (!parsedData) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();

    const scaleX = canvas.width / rect.width;
    const canvasX = (e.clientX - rect.left) * scaleX;

    // Calculate visible range
    const traceLengths = Object.values(parsedData.traces).map(trace => trace.length);
    const maxTraceLength = Math.max(...traceLengths);
    const dataLength = maxTraceLength;
    const visiblePoints = Math.floor(canvas.width / zoomLevel);
    const startIndex = Math.floor(scrollPosition * (dataLength - visiblePoints));
    const endIndex = Math.min(startIndex + visiblePoints, dataLength);

    // Calculate the actual ratio for real data
    const dataPointsPerBase = maxTraceLength / parsedData.baseCalls.length;

    // Find closest position
    let closestPosition = null;
    let closestDistance = Infinity;

    for (let i = 0; i < parsedData.baseCalls.length; i++) {
      const peakPosition = parsedData.peakLocations && parsedData.peakLocations[i]
        ? parsedData.peakLocations[i]
        : (i * maxTraceLength / parsedData.baseCalls.length);

      if (peakPosition < startIndex || peakPosition > endIndex) continue;

      const baseX = ((peakPosition - startIndex) / (endIndex - startIndex)) * canvas.width;
      const distance = Math.abs(canvasX - baseX);

      if (distance < closestDistance) {
        closestDistance = distance;
        closestPosition = i;
      }
    }

    if (closestPosition !== null && closestDistance < 50 && closestPosition >= 0) {
      setHoveredPosition(closestPosition);
    } else {
      setHoveredPosition(null);
    }
  };

  // Add mouse leave handler
  const handleCanvasMouseLeave = () => {
    setHoveredPosition(null);
  };

  const handleScrollbarChange = (e) => {
    const newPosition = parseFloat(e.target.value) / 10000;
    setScrollPosition(newPosition);
  };

  const resetView = () => {
    setZoomLevel(2.5);
    setScrollPosition(0);
    // Clear selection when resetting view
    setSelectedPosition(null);
    setSelectedNucleotide(null);
  };

  const toggleChannel = (channel) => {
    setShowChannels(prev => ({
      ...prev,
      [channel]: !prev[channel]
    }));
  };

  const exportSequence = () => {
    if (!parsedData) return;

    const fasta = `>${fileName}\n${parsedData.sequence}`;
    const blob = new Blob([fasta], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${fileName.replace('.ab1', '')}.fasta`;
    a.click();
    URL.revokeObjectURL(url);
  };

  if (loading) {
    return (
      <div className="bg-white rounded-lg border p-6">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Parsing chromatogram data...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg border p-6">
        <div className="text-center py-8">
          <div className="mb-6">
            <svg className="w-16 h-16 mx-auto text-red-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <h3 className="text-2xl font-bold text-red-600 mb-2">Could not load Chromatogram Data</h3>
            <p className="text-lg text-gray-700">Please contact a Director to fix this issue</p>
          </div>
          {onClose && (
            <button
              onClick={onClose}
              className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
            >
              Close
            </button>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg border flex flex-col h-full">
      {/* Confirmation Modal */}
      {showConfirmModal && pendingEdit && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={cancelBaseEdit}>
          <div className="bg-white rounded-lg shadow-xl p-6 max-w-md mx-4" onClick={(e) => e.stopPropagation()}>
            <h3 className="text-lg font-semibold text-gray-900 mb-4">Confirm Base Change</h3>
            <div className="mb-6">
              <p className="text-gray-700 mb-2">
                Are you sure you want to change the base at position <span className="font-bold">{pendingEdit.position + 1}</span>?
              </p>
              <div className="flex items-center justify-center space-x-4 p-4 bg-gray-50 rounded">
                <div className="text-center">
                  <div className="text-xs text-gray-500 mb-1">From</div>
                  <div className="text-2xl font-bold text-red-600">{pendingEdit.oldBase}</div>
                </div>
                <div className="text-2xl text-gray-400">&rarr;</div>
                <div className="text-center">
                  <div className="text-xs text-gray-500 mb-1">To</div>
                  <div className="text-2xl font-bold text-green-600">{pendingEdit.newBase}</div>
                </div>
              </div>
            </div>
            <div className="flex space-x-3">
              <button
                onClick={cancelBaseEdit}
                className="flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 font-medium"
              >
                Cancel
              </button>
              <button
                onClick={confirmBaseEdit}
                className="flex-1 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 font-medium"
              >
                Confirm
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Controls */}
      <div className="p-4 border-b border-gray-200">
        <div className="flex justify-between items-center mb-4">
          <h4 className="text-lg font-semibold text-gray-900">Chromatogram Viewer</h4>
          <div className="flex items-center space-x-2">
            <button
              onClick={exportSequence}
              className="px-3 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700 flex items-center space-x-1"
            >
              <Download className="w-4 h-4" />
              <span>Export FASTA</span>
            </button>
            <button
              onClick={resetView}
              className="px-3 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-700 flex items-center space-x-1"
            >
              <RotateCcw className="w-4 h-4" />
              <span>Reset View</span>
            </button>
            {onClose && (
              <button
                onClick={onClose}
                className="px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700 flex items-center space-x-1"
                title="Close chromatogram viewer"
              >
                <span>&times;</span>
                <span>Close</span>
              </button>
            )}
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          {/* Zoom Controls */}
          <div className="flex items-center space-x-2">
            <span className="text-sm font-medium text-gray-700">Zoom:</span>
            <button
              onClick={() => handleZoom(-0.5)}
              className="p-1 border border-gray-300 rounded hover:bg-gray-50"
            >
              <ZoomOut className="w-4 h-4" />
            </button>
            <span className="text-sm text-gray-600 min-w-[3rem] text-center">
              {zoomLevel.toFixed(1)}x
            </span>
            <button
              onClick={() => handleZoom(0.5)}
              className="p-1 border border-gray-300 rounded hover:bg-gray-50"
            >
              <ZoomIn className="w-4 h-4" />
            </button>
          </div>
        </div>
      </div>

      {/* Chromatogram Canvas */}
      <div className="p-4 flex-1 flex flex-col overflow-hidden">
        {/* Combined Controls: Selected Position + Highlight */}
        <div className="mb-2 p-3 bg-gradient-to-r from-orange-50 to-yellow-50 border border-orange-200 rounded-lg">
          <div className="flex items-center gap-3 flex-wrap">
            {/* Selected Position Section */}
            {selectedPosition !== null && selectedNucleotide ? (
              <>
                <div className="flex items-center gap-2">
                  <span className="text-sm text-orange-900">
                    Selected: <span className="font-bold">{selectedNucleotide}{selectedPosition + 1}</span>
                  </span>
                  <span className="text-xs text-orange-700">
                    (Press A/T/G/C/N)
                  </span>
                  {editedPositions.has(selectedPosition) && (
                    <span className="text-xs text-green-600 font-medium">&bull; Edited</span>
                  )}
                  <button
                    onClick={() => {
                      setSelectedPosition(null);
                      setSelectedNucleotide(null);
                    }}
                    className="text-orange-600 hover:text-orange-800 text-lg leading-none"
                    title="Clear selection"
                  >
                    &times;
                  </button>
                </div>
                <div className="h-6 w-px bg-gray-300"></div>
              </>
            ) : (
              <span className="text-sm text-gray-500 italic">Click a base to select</span>
            )}
            
            {/* Highlight Section */}
            <div className="flex items-center gap-2 flex-1">
              <span className="text-sm font-medium text-yellow-900">Highlight:</span>
              <input
                type="number"
                value={highlightStart}
                onChange={(e) => setHighlightStart(e.target.value)}
                placeholder="Start"
                min="1"
                max={parsedData?.sequenceLength - 1 || 0}
                className="w-16 px-2 py-1 text-sm border border-yellow-300 rounded focus:ring-1 focus:ring-yellow-500"
              />
              <span className="text-sm text-yellow-700">to</span>
              <input
                type="number"
                value={highlightEnd}
                onChange={(e) => setHighlightEnd(e.target.value)}
                placeholder="End"
                min="0"
                max={parsedData?.sequenceLength || 1}
                className="w-16 px-2 py-1 text-sm border border-yellow-300 rounded focus:ring-1 focus:ring-yellow-500"
              />
              <button
                onClick={() => setShowHighlight(!showHighlight)}
                disabled={!highlightStart || !highlightEnd}
                className={`px-2 py-1 text-sm rounded ${showHighlight
                  ? 'bg-yellow-600 text-white hover:bg-yellow-700'
                  : 'bg-white text-yellow-700 border border-yellow-300 hover:bg-yellow-50'
                  } disabled:opacity-50`}
              >
                {showHighlight ? 'Hide' : 'Show'}
              </button>
              <button
                onClick={() => {
                  if (highlightStart && highlightEnd && parsedData) {
                    const startPos = parseInt(highlightStart) - 1;
                    const endPos = parseInt(highlightEnd) - 1;
                    if (!isNaN(startPos) && !isNaN(endPos) && startPos >= 0 && endPos < parsedData.baseCalls.length && startPos <= endPos) {
                      const sequence = parsedData.baseCalls.slice(startPos, endPos + 1).join('');
                      navigator.clipboard.writeText(sequence);
                    }
                  }
                }}
                disabled={!highlightStart || !highlightEnd}
                className="px-2 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700 disabled:opacity-50"
              >
                Copy
              </button>
              {highlightStart && highlightEnd && parsedData && (() => {
                const startPos = parseInt(highlightStart) - 1;
                const endPos = parseInt(highlightEnd) - 1;
                if (!isNaN(startPos) && !isNaN(endPos) && startPos >= 0 && endPos < parsedData.baseCalls.length && startPos <= endPos) {
                  return (
                    <span className="text-sm text-yellow-700">
                      ({endPos - startPos + 1} bases)
                    </span>
                  );
                }
              })()}
            </div>
          </div>
        </div>

        {/* Canvas container - takes remaining height */}
        <div className="flex-1 min-h-0">
          <canvas
            ref={canvasRef}
            onClick={handleCanvasClick}
            onDoubleClick={handleNavigation}
            onMouseMove={handleCanvasMouseMove}
            onMouseLeave={handleCanvasMouseLeave}
            className="w-full h-full border border-gray-200 rounded cursor-pointer"
          />
        </div>

        {/* Click instruction */}
        <div className="mt-2 text-center">
          <p className="text-xs text-gray-500">
            Single-click to select a position &bull; Double-click to navigate to that region
          </p>
        </div>

        {/* Horizontal Scroll Bar */}
        <div className="mt-2 px-2">
          <div className="flex items-center space-x-2">
            <span className="text-xs text-gray-500 min-w-[3rem]">Start</span>
            <input
              type="range"
              min="0"
              max="10000"
              value={scrollPosition * 10000}
              onChange={handleScrollbarChange}
              className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              style={{
                background: `linear-gradient(to right, #4F46E5 0%, #4F46E5 ${scrollPosition * 100}%, #E5E7EB ${scrollPosition * 100}%, #E5E7EB 100%)`
              }}
            />
            <span className="text-xs text-gray-500 min-w-[3rem]">End</span>
          </div>

          <div className="mt-1 text-center">
            <span className="text-xs text-gray-600">
              Showing positions {(() => {
                if (!canvasRef.current || !parsedData || !parsedData.traces) return '0 - 0';

                try {
                  // Calculate the actual base positions being displayed
                  const traceLengths = Object.values(parsedData.traces).map(trace => trace.length);
                  const maxTraceLength = Math.max(...traceLengths);
                  if (maxTraceLength === 0) return '0 - 0';

                  const dataLength = maxTraceLength;
                  const canvasWidth = canvasRef.current.width || 1200; // fallback to default width
                  const visiblePoints = Math.floor(canvasWidth / zoomLevel);
                  const startIndex = Math.floor(scrollPosition * (dataLength - visiblePoints));
                  const endIndex = Math.min(startIndex + visiblePoints, dataLength);

                  // Convert trace indices to base positions
                  const startBasePos = Math.floor(startIndex * parsedData.baseCalls.length / maxTraceLength);
                  const endBasePos = Math.floor(endIndex * parsedData.baseCalls.length / maxTraceLength);

                  return `${startBasePos + 1} - ${Math.min(endBasePos, parsedData.baseCalls.length)}`;
                } catch (error) {
                  return '0 - 0';
                }
              })()}
            </span>
          </div>
        </div>

      </div>
    </div>
  );
};

export default ChromatogramViewer;